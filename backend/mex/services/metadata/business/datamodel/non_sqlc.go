package datamodel

import (
	"context"
	"database/sql"
	"time"

	"github.com/jackc/pgx/v5/pgtype"

	"github.com/d4l-data4life/mex/mex/shared/coll/accumap"
	"github.com/d4l-data4life/mex/mex/shared/db"

	pbItems "github.com/d4l-data4life/mex/mex/services/metadata/endpoints/items/pb"
)

// This file contains functions that were manually crafted, but look as if they were generated by SQLC.
// There is a bug in SQLC which prevents code generation (yet) for some special cases when dealing with functions.
// Until the bug is resolved, we will use the below functions.

type TreeNodeRow struct {
	NodeID       string
	Display      pgtype.Text
	ParentNodeID pgtype.Text
	Language     pgtype.Text
	Place        pgtype.Int4
}

const dbReadTreeNodes = `
select
	liwbi.business_id,
	iwl.target_business_id as parent_id,
	civ.field_value as display,
	civ."language",
	civ.place
from
	latest_items_with_business_id liwbi
left outer join items_with_links($3::TEXT[]) iwl
	on iwl.source_business_id = liwbi.business_id
left outer join current_item_values civ
	on civ.item_id = liwbi.item_id and civ.field_name = $1
where
	liwbi.entity_name = $2
order by
	business_id asc,
	language asc,
	place asc
`

func nodeAccu(node *pbItems.ComputeItemsTreeResponse_TreeNode, row *TreeNodeRow) *pbItems.ComputeItemsTreeResponse_TreeNode {
	if node.NodeId != row.NodeID {
		panic("node IDs not equal")
	}

	if node.ParentNodeId == nil && row.ParentNodeID.Valid {
		panic("parent node ID mismatch")
	}

	if node.ParentNodeId != nil && !row.ParentNodeID.Valid {
		panic("parent node ID mismatch")
	}

	if row.Display.Valid {
		node.Display = append(node.Display, &pbItems.ComputeItemsTreeResponse_Display{
			Language: db.StringOrNil(row.Language),
			Display:  row.Display.String,
			Place:    db.Int32OrNil(row.Place),
		})
	}

	return node
}

func nodeZero(row *TreeNodeRow) *pbItems.ComputeItemsTreeResponse_TreeNode {
	node := pbItems.ComputeItemsTreeResponse_TreeNode{
		NodeId:       row.NodeID,
		ParentNodeId: db.StringOrNil(row.ParentNodeID), // empty in case of invalid is fine
		Display:      []*pbItems.ComputeItemsTreeResponse_Display{},
	}

	if row.Display.Valid {
		node.Display = []*pbItems.ComputeItemsTreeResponse_Display{{
			Language: db.StringOrNil(row.Language),
			Display:  row.Display.String,
			Place:    db.Int32OrNil(row.Place),
		}}
	}

	return &node
}

func nodeKeyer(row *TreeNodeRow) string {
	return row.NodeID
}

//nolint:lll
func (q *Queries) DbReadTreeNodes(ctx context.Context, nodeEntityType string, linkFieldName string, displayFieldName string) (accumap.Accumap[*TreeNodeRow, *pbItems.ComputeItemsTreeResponse_TreeNode], error) {
	rows, err := q.db.Query(ctx, dbReadTreeNodes, displayFieldName, nodeEntityType, []string{linkFieldName})
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	m := accumap.NewAccumap(nodeAccu, nodeZero, nodeKeyer)
	for rows.Next() {
		n := TreeNodeRow{}
		if err := rows.Scan(&n.NodeID, &n.ParentNodeID, &n.Display, &n.Language, &n.Place); err != nil {
			return nil, err
		}
		m.Push(&n)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return m, nil
}

type ItemsWithLink struct {
	SourceItemID              string
	SourceCreatedAt           time.Time
	SourceOwner               string
	SourceEntityName          string
	SourceBusinessIDFieldName sql.NullString
	SourceBusinessID          string
	SourceLinkFieldName       string
	TargetBusinessID          string
	TargetItemID              sql.NullString
}

const dbItemsByLinks = `
select
	ip.source_item_id,
	ip.source_created_at,
	ip.source_owner,
	ip.source_entity_name,
	ip.source_business_id_field_name,
	ip.source_business_id,
	ip.source_link_field_name,
	ip.target_business_id,
	ip.target_item_id
from
	items_with_links($1) ip
inner join latest_items_with_business_id liwbi
	on liwbi.business_id = ip.target_business_id
where
	ip.source_business_id = $2
`

func (q *Queries) DbItemsByLinks(ctx context.Context, linkFieldNames []string, sourceBusinessID string) ([]ItemsWithLink, error) {
	rows, err := q.db.Query(ctx, dbItemsByLinks, linkFieldNames, sourceBusinessID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ItemsWithLink
	for rows.Next() {
		var i ItemsWithLink
		if err := rows.Scan(
			&i.SourceItemID,
			&i.SourceCreatedAt,
			&i.SourceOwner,
			&i.SourceEntityName,
			&i.SourceBusinessIDFieldName,
			&i.SourceBusinessID,
			&i.SourceLinkFieldName,
			&i.TargetBusinessID,
			&i.TargetItemID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dbSimpleAggregationByBusinessID = `-- name: DbSimpleAggregationByBusinessId :many
select distinct civ.item_id, civ.field_name, civ.field_value, civ.place, civ.language
from items_with_links($1) iwl
inner join current_item_values civ
on civ.item_id = iwl.source_item_id
where iwl.source_business_id = $2 and civ.field_name <> iwl.source_business_id_field_name
order by civ.field_name asc, civ.place asc, civ.field_value asc
`

type DbSimpleAggregationByBusinessIdRow struct {
	ItemID     string
	FieldName  string
	FieldValue string
	Place      int32
	Language   sql.NullString
}

func (q *Queries) DbSimpleAggregationByBusinessID(ctx context.Context, linkFieldNames []string, sourceBusinessID string) ([]DbSimpleAggregationByBusinessIdRow, error) {
	rows, err := q.db.Query(ctx, dbSimpleAggregationByBusinessID, linkFieldNames, sourceBusinessID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DbSimpleAggregationByBusinessIdRow
	for rows.Next() {
		var i DbSimpleAggregationByBusinessIdRow
		if err := rows.Scan(
			&i.ItemID,
			&i.FieldName,
			&i.FieldValue,
			&i.Place,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

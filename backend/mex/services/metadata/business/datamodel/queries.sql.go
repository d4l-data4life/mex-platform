// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: queries.sql

package datamodel

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const dbAggregationCandidateValues = `-- name: DbAggregationCandidateValues :many
select civ.field_name, y.partition_business_id, civ.place, civ.field_value, civ.language, civ.item_id
from (select distinct row_number()
                      over (partition by x.partition_business_id order by x.candidate_created_at desc) as date_rank,
                      x.candidate_id                                                                   as candidate_id,
                      x.partition_business_id                                                          as partition_business_id
      from (select i.id as candidate_id, i.created_at as candidate_created_at, iv.field_value as partition_business_id
            from items i
                     join item_values iv
                          on i.id = iv.item_id and iv.field_name = $1
            where i.business_id = $2) x) y
         join current_item_values civ
              on y.candidate_id = civ.item_id and civ.field_name <> $3
where y.date_rank = 1
order by civ.field_name asc, civ.item_id asc, y.partition_business_id asc, civ.place asc, civ.field_value asc
`

type DbAggregationCandidateValuesParams struct {
	PartitionField string
	BusinessID     pgtype.Text
	SourceIDField  string
}

type DbAggregationCandidateValuesRow struct {
	FieldName           string
	PartitionBusinessID string
	Place               int32
	FieldValue          string
	Language            pgtype.Text
	ItemID              string
}

func (q *Queries) DbAggregationCandidateValues(ctx context.Context, arg DbAggregationCandidateValuesParams) ([]DbAggregationCandidateValuesRow, error) {
	rows, err := q.db.Query(ctx, dbAggregationCandidateValues, arg.PartitionField, arg.BusinessID, arg.SourceIDField)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DbAggregationCandidateValuesRow
	for rows.Next() {
		var i DbAggregationCandidateValuesRow
		if err := rows.Scan(
			&i.FieldName,
			&i.PartitionBusinessID,
			&i.Place,
			&i.FieldValue,
			&i.Language,
			&i.ItemID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dbComputeVersions = `-- name: DbComputeVersions :many
select y.item_id, y.created_at, y.version from (
	select x.item_id, x.created_at, x.owner, x.entity_name, x.business_id, x.business_id_field_name, row_number() over () as version
	from (
		select iwbi2.item_id, iwbi2.created_at, iwbi2.owner, iwbi2.entity_name, iwbi2.business_id, iwbi2.business_id_field_name
		from items_with_business_id iwbi1
		inner join items_with_business_id iwbi2
			on iwbi1.business_id = iwbi2.business_id
		where iwbi1.item_id = $1
		order by iwbi2.created_at
	) x
) y
order by y.version desc
`

type DbComputeVersionsRow struct {
	ItemID    string
	CreatedAt pgtype.Timestamptz
	Version   int64
}

func (q *Queries) DbComputeVersions(ctx context.Context, itemID string) ([]DbComputeVersionsRow, error) {
	rows, err := q.db.Query(ctx, dbComputeVersions, itemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DbComputeVersionsRow
	for rows.Next() {
		var i DbComputeVersionsRow
		if err := rows.Scan(&i.ItemID, &i.CreatedAt, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dbCreateItem = `-- name: DbCreateItem :one
INSERT INTO items (created_at, id, owner, entity_name, business_id_field_name, business_id, hash)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING created_at, id, owner, entity_name, business_id, business_id_field_name, hash
`

type DbCreateItemParams struct {
	CreatedAt           pgtype.Timestamptz
	ID                  string
	Owner               string
	EntityName          string
	BusinessIDFieldName pgtype.Text
	BusinessID          pgtype.Text
	Hash                pgtype.Text
}

func (q *Queries) DbCreateItem(ctx context.Context, arg DbCreateItemParams) (Item, error) {
	row := q.db.QueryRow(ctx, dbCreateItem,
		arg.CreatedAt,
		arg.ID,
		arg.Owner,
		arg.EntityName,
		arg.BusinessIDFieldName,
		arg.BusinessID,
		arg.Hash,
	)
	var i Item
	err := row.Scan(
		&i.CreatedAt,
		&i.ID,
		&i.Owner,
		&i.EntityName,
		&i.BusinessID,
		&i.BusinessIDFieldName,
		&i.Hash,
	)
	return i, err
}

const dbCreateItemValue = `-- name: DbCreateItemValue :one
INSERT INTO item_values (created_at, id, revision, deleted, field_name, field_value, language, place, item_id)
VALUES ($1, $2, DEFAULT, $3, $4, $5, $6, $7, $8)
RETURNING created_at, id, revision, deleted, language, field_name, field_value, place, item_id, revision_comment
`

type DbCreateItemValueParams struct {
	CreatedAt  pgtype.Timestamptz
	ID         string
	Deleted    bool
	FieldName  string
	FieldValue string
	Language   pgtype.Text
	Place      int32
	ItemID     string
}

func (q *Queries) DbCreateItemValue(ctx context.Context, arg DbCreateItemValueParams) (ItemValue, error) {
	row := q.db.QueryRow(ctx, dbCreateItemValue,
		arg.CreatedAt,
		arg.ID,
		arg.Deleted,
		arg.FieldName,
		arg.FieldValue,
		arg.Language,
		arg.Place,
		arg.ItemID,
	)
	var i ItemValue
	err := row.Scan(
		&i.CreatedAt,
		&i.ID,
		&i.Revision,
		&i.Deleted,
		&i.Language,
		&i.FieldName,
		&i.FieldValue,
		&i.Place,
		&i.ItemID,
		&i.RevisionComment,
	)
	return i, err
}

const dbCreateRelation = `-- name: DbCreateRelation :one
INSERT INTO relations (created_at, id, owner, deleted, type, source_item_id, target_item_id, info_item_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING created_at, id, deleted, owner, source_item_id, type, target_item_id, info_item_id
`

type DbCreateRelationParams struct {
	CreatedAt    pgtype.Timestamptz
	ID           string
	Owner        string
	Deleted      bool
	Type         string
	SourceItemID string
	TargetItemID string
	InfoItemID   pgtype.Text
}

func (q *Queries) DbCreateRelation(ctx context.Context, arg DbCreateRelationParams) (Relation, error) {
	row := q.db.QueryRow(ctx, dbCreateRelation,
		arg.CreatedAt,
		arg.ID,
		arg.Owner,
		arg.Deleted,
		arg.Type,
		arg.SourceItemID,
		arg.TargetItemID,
		arg.InfoItemID,
	)
	var i Relation
	err := row.Scan(
		&i.CreatedAt,
		&i.ID,
		&i.Deleted,
		&i.Owner,
		&i.SourceItemID,
		&i.Type,
		&i.TargetItemID,
		&i.InfoItemID,
	)
	return i, err
}

const dbCreateRelationsFromBusinessIDs = `-- name: DbCreateRelationsFromBusinessIDs :execrows
INSERT INTO "relations" ("created_at", "id", "deleted", "owner", "type", "source_item_id", "target_item_id", "info_item_id")
SELECT
	NOW()              AS "created_at",
	uuid_generate_v4() AS "id",
	false              AS "deleted",
	$1                 AS "owner",
	$2                 AS "type",
	"source_item_id"   AS "source_item_id",
	"target_item_id"   AS "target_item_id",
	null               AS "info_item_id"
FROM (
	select civ.item_id as source_item_id, liwbi.item_id as target_item_id
	from current_item_values civ
	inner join latest_items_with_business_id liwbi
		on liwbi.business_id = civ.field_value and civ.field_name = $4
	where civ.item_id = $3 and liwbi.item_id <> $3
) unused1
`

type DbCreateRelationsFromBusinessIDsParams struct {
	Owner     string
	Type      string
	ItemID    string
	FieldName string
}

func (q *Queries) DbCreateRelationsFromBusinessIDs(ctx context.Context, arg DbCreateRelationsFromBusinessIDsParams) (int64, error) {
	result, err := q.db.Exec(ctx, dbCreateRelationsFromBusinessIDs,
		arg.Owner,
		arg.Type,
		arg.ItemID,
		arg.FieldName,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const dbDeleteAllItems = `-- name: DbDeleteAllItems :exec
DELETE FROM items
`

func (q *Queries) DbDeleteAllItems(ctx context.Context) error {
	_, err := q.db.Exec(ctx, dbDeleteAllItems)
	return err
}

const dbDeleteItem = `-- name: DbDeleteItem :exec
DELETE FROM items where id = $1
`

func (q *Queries) DbDeleteItem(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, dbDeleteItem, id)
	return err
}

const dbDeleteItems = `-- name: DbDeleteItems :execrows
DELETE FROM items where id = ANY($1::text[])
`

func (q *Queries) DbDeleteItems(ctx context.Context, itemIds []string) (int64, error) {
	result, err := q.db.Exec(ctx, dbDeleteItems, itemIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const dbFollowRelationsTwoSteps = `-- name: DbFollowRelationsTwoSteps :many
select distinct r1."type" as relation_type_1 , r2.type as relation_type_2, r2.target_item_id
from relations r2
inner join relations r1
  on r2.source_item_id = r1.target_item_id
where r1.source_item_id = $1
`

type DbFollowRelationsTwoStepsRow struct {
	RelationType1 string
	RelationType2 string
	TargetItemID  string
}

func (q *Queries) DbFollowRelationsTwoSteps(ctx context.Context, sourceItemID string) ([]DbFollowRelationsTwoStepsRow, error) {
	rows, err := q.db.Query(ctx, dbFollowRelationsTwoSteps, sourceItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DbFollowRelationsTwoStepsRow
	for rows.Next() {
		var i DbFollowRelationsTwoStepsRow
		if err := rows.Scan(&i.RelationType1, &i.RelationType2, &i.TargetItemID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dbGetItem = `-- name: DbGetItem :many
SELECT created_at, id, owner, entity_name, business_id, business_id_field_name, hash FROM items
WHERE id = $1
`

func (q *Queries) DbGetItem(ctx context.Context, id string) ([]Item, error) {
	rows, err := q.db.Query(ctx, dbGetItem, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Item
	for rows.Next() {
		var i Item
		if err := rows.Scan(
			&i.CreatedAt,
			&i.ID,
			&i.Owner,
			&i.EntityName,
			&i.BusinessID,
			&i.BusinessIDFieldName,
			&i.Hash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dbGetItemValues = `-- name: DbGetItemValues :many
SELECT id, item_id, field_name, field_value, place, revision, language FROM current_item_values
WHERE item_id = $1
ORDER BY field_name ASC, place ASC
`

func (q *Queries) DbGetItemValues(ctx context.Context, itemID string) ([]CurrentItemValue, error) {
	rows, err := q.db.Query(ctx, dbGetItemValues, itemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CurrentItemValue
	for rows.Next() {
		var i CurrentItemValue
		if err := rows.Scan(
			&i.ID,
			&i.ItemID,
			&i.FieldName,
			&i.FieldValue,
			&i.Place,
			&i.Revision,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dbGetItemsCount = `-- name: DbGetItemsCount :one
SELECT COUNT(*) FROM items
`

func (q *Queries) DbGetItemsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, dbGetItemsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const dbGetRelation = `-- name: DbGetRelation :one
SELECT created_at, id, deleted, owner, source_item_id, type, target_item_id, info_item_id FROM relations
WHERE id = $1
LIMIT 1
`

func (q *Queries) DbGetRelation(ctx context.Context, id string) (Relation, error) {
	row := q.db.QueryRow(ctx, dbGetRelation, id)
	var i Relation
	err := row.Scan(
		&i.CreatedAt,
		&i.ID,
		&i.Deleted,
		&i.Owner,
		&i.SourceItemID,
		&i.Type,
		&i.TargetItemID,
		&i.InfoItemID,
	)
	return i, err
}

const dbGetRelationTargetsForSourceAndType = `-- name: DbGetRelationTargetsForSourceAndType :many
SELECT target_item_id FROM relations
WHERE source_item_id = $1 and type = $2
`

type DbGetRelationTargetsForSourceAndTypeParams struct {
	SourceItemID string
	Type         string
}

func (q *Queries) DbGetRelationTargetsForSourceAndType(ctx context.Context, arg DbGetRelationTargetsForSourceAndTypeParams) ([]string, error) {
	rows, err := q.db.Query(ctx, dbGetRelationTargetsForSourceAndType, arg.SourceItemID, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var target_item_id string
		if err := rows.Scan(&target_item_id); err != nil {
			return nil, err
		}
		items = append(items, target_item_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dbImputeBusinessId = `-- name: DbImputeBusinessId :execrows
update items
set business_id = val.business_id
from
	(SELECT i."id" as "item_id", iv."field_value" AS "business_id"
    FROM "items" i
    INNER JOIN "item_values" iv
    ON iv."field_name" = i."business_id_field_name" AND iv."item_id" = i."id"
	) as val
where items.id = val.item_id and items.business_id IS NULL
`

func (q *Queries) DbImputeBusinessId(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, dbImputeBusinessId)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const dbIncrementItemCounter = `-- name: DbIncrementItemCounter :exec
INSERT INTO item_view_counts (created_at, item_id, user_id, counts)
VALUES ($1, $2, $3, $4)
ON CONFLICT (item_id, user_id) DO UPDATE
    SET counts = item_view_counts.counts + EXCLUDED.counts
`

type DbIncrementItemCounterParams struct {
	CreatedAt pgtype.Timestamptz
	ItemID    string
	UserID    string
	Counts    int32
}

// Perform an UPSERT:
// - Either INSERT a new row with initial count 1, or, if already present
// - UPDATE the row by incrementing the count
func (q *Queries) DbIncrementItemCounter(ctx context.Context, arg DbIncrementItemCounterParams) error {
	_, err := q.db.Exec(ctx, dbIncrementItemCounter,
		arg.CreatedAt,
		arg.ItemID,
		arg.UserID,
		arg.Counts,
	)
	return err
}

const dbLatestItemByBusinessId = `-- name: DbLatestItemByBusinessId :one
select i.id as item_id, i."owner", i.entity_name , i.business_id_field_name, i.business_id, TO_CHAR(i.created_at, 'YYYY-MM-DD"T"HH24:MI:SSZ') as created_at
from items i
inner join latest_items_with_business_id liwbi
	on i.id =liwbi.item_id
where liwbi.business_id = $1
`

type DbLatestItemByBusinessIdRow struct {
	ItemID              string
	Owner               string
	EntityName          string
	BusinessIDFieldName pgtype.Text
	BusinessID          pgtype.Text
	CreatedAt           string
}

func (q *Queries) DbLatestItemByBusinessId(ctx context.Context, businessID string) (DbLatestItemByBusinessIdRow, error) {
	row := q.db.QueryRow(ctx, dbLatestItemByBusinessId, businessID)
	var i DbLatestItemByBusinessIdRow
	err := row.Scan(
		&i.ItemID,
		&i.Owner,
		&i.EntityName,
		&i.BusinessIDFieldName,
		&i.BusinessID,
		&i.CreatedAt,
	)
	return i, err
}

const dbLatestItemValuesByBusinessId = `-- name: DbLatestItemValuesByBusinessId :many
select civ.id, civ.item_id, civ.field_name, civ.field_value, civ.place, civ.revision, civ.language
from latest_items_with_business_id liwbi
inner join current_item_values civ
  on civ.item_id = liwbi.item_id
where liwbi.business_id = $1
`

func (q *Queries) DbLatestItemValuesByBusinessId(ctx context.Context, businessID string) ([]CurrentItemValue, error) {
	rows, err := q.db.Query(ctx, dbLatestItemValuesByBusinessId, businessID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CurrentItemValue
	for rows.Next() {
		var i CurrentItemValue
		if err := rows.Scan(
			&i.ID,
			&i.ItemID,
			&i.FieldName,
			&i.FieldValue,
			&i.Place,
			&i.Revision,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dbListHashesPresentLatestOnly = `-- name: DbListHashesPresentLatestOnly :many
SELECT c.hash FROM (
    SELECT i2.hash, row_number() over (partition by i2.business_id order by i2.created_at desc) as date_rank
    FROM items i2
    WHERE i2.business_id in (
        SELECT i1.business_id
        FROM items i1
        WHERE i1.hash = ANY ($1::text[]) AND i1.business_id IS NOT NULL
    )
 ) c
WHERE c.date_rank = 1 and c.hash = ANY ($1::text[])
`

func (q *Queries) DbListHashesPresentLatestOnly(ctx context.Context, hashes []string) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, dbListHashesPresentLatestOnly, hashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Text
	for rows.Next() {
		var hash pgtype.Text
		if err := rows.Scan(&hash); err != nil {
			return nil, err
		}
		items = append(items, hash)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dbListHashesPresentSimple = `-- name: DbListHashesPresentSimple :many
SELECT hash
FROM items
WHERE hash = ANY($1::text[])
`

func (q *Queries) DbListHashesPresentSimple(ctx context.Context, hashes []string) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, dbListHashesPresentSimple, hashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Text
	for rows.Next() {
		var hash pgtype.Text
		if err := rows.Scan(&hash); err != nil {
			return nil, err
		}
		items = append(items, hash)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dbListItemValues = `-- name: DbListItemValues :many
SELECT id, item_id, field_name, field_value, place, revision, language FROM current_item_values
ORDER BY item_id ASC, field_name ASC, place ASC
`

func (q *Queries) DbListItemValues(ctx context.Context) ([]CurrentItemValue, error) {
	rows, err := q.db.Query(ctx, dbListItemValues)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CurrentItemValue
	for rows.Next() {
		var i CurrentItemValue
		if err := rows.Scan(
			&i.ID,
			&i.ItemID,
			&i.FieldName,
			&i.FieldValue,
			&i.Place,
			&i.Revision,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dbListItems = `-- name: DbListItems :many
SELECT item_id, created_at, owner, entity_name, business_id, business_id_field_name FROM items_nullable_business_id
WHERE item_id >= $1 ORDER BY item_id ASC LIMIT $2
`

type DbListItemsParams struct {
	ItemID string
	Limit  int32
}

func (q *Queries) DbListItems(ctx context.Context, arg DbListItemsParams) ([]ItemsNullableBusinessID, error) {
	rows, err := q.db.Query(ctx, dbListItems, arg.ItemID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ItemsNullableBusinessID
	for rows.Next() {
		var i ItemsNullableBusinessID
		if err := rows.Scan(
			&i.ItemID,
			&i.CreatedAt,
			&i.Owner,
			&i.EntityName,
			&i.BusinessID,
			&i.BusinessIDFieldName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dbListItemsForBusinessId = `-- name: DbListItemsForBusinessId :many
select item_id, created_at, owner, entity_name, business_id, business_id_field_name from items_with_business_id where business_id = $1 order by created_at asc
`

func (q *Queries) DbListItemsForBusinessId(ctx context.Context, businessID string) ([]ItemsWithBusinessID, error) {
	rows, err := q.db.Query(ctx, dbListItemsForBusinessId, businessID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ItemsWithBusinessID
	for rows.Next() {
		var i ItemsWithBusinessID
		if err := rows.Scan(
			&i.ItemID,
			&i.CreatedAt,
			&i.Owner,
			&i.EntityName,
			&i.BusinessID,
			&i.BusinessIDFieldName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dbListItemsOfType = `-- name: DbListItemsOfType :many
SELECT item_id, created_at, owner, entity_name, business_id, business_id_field_name FROM items_nullable_business_id
WHERE item_id >= $1 AND entity_name = $2 ORDER BY item_id ASC LIMIT $3
`

type DbListItemsOfTypeParams struct {
	ItemID     string
	EntityName string
	Limit      int32
}

func (q *Queries) DbListItemsOfType(ctx context.Context, arg DbListItemsOfTypeParams) ([]ItemsNullableBusinessID, error) {
	rows, err := q.db.Query(ctx, dbListItemsOfType, arg.ItemID, arg.EntityName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ItemsNullableBusinessID
	for rows.Next() {
		var i ItemsNullableBusinessID
		if err := rows.Scan(
			&i.ItemID,
			&i.CreatedAt,
			&i.Owner,
			&i.EntityName,
			&i.BusinessID,
			&i.BusinessIDFieldName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dbListItemsWithBusinessId = `-- name: DbListItemsWithBusinessId :many
select item_id, created_at, owner, entity_name, business_id, business_id_field_name from items_with_business_id order by business_id, created_at asc
`

func (q *Queries) DbListItemsWithBusinessId(ctx context.Context) ([]ItemsWithBusinessID, error) {
	rows, err := q.db.Query(ctx, dbListItemsWithBusinessId)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ItemsWithBusinessID
	for rows.Next() {
		var i ItemsWithBusinessID
		if err := rows.Scan(
			&i.ItemID,
			&i.CreatedAt,
			&i.Owner,
			&i.EntityName,
			&i.BusinessID,
			&i.BusinessIDFieldName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dbListRelations = `-- name: DbListRelations :many
SELECT created_at, id, deleted, owner, source_item_id, type, target_item_id, info_item_id FROM relations
`

func (q *Queries) DbListRelations(ctx context.Context) ([]Relation, error) {
	rows, err := q.db.Query(ctx, dbListRelations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Relation
	for rows.Next() {
		var i Relation
		if err := rows.Scan(
			&i.CreatedAt,
			&i.ID,
			&i.Deleted,
			&i.Owner,
			&i.SourceItemID,
			&i.Type,
			&i.TargetItemID,
			&i.InfoItemID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
